<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>17_5_Using_Scripts_in_Libwally</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="using-scripts-in-libwally">17.5: Using Scripts in Libwally</h1>
<blockquote>
<p>:information_source: <strong>NOTE:</strong> This section has been
recently added to the course and is an early draft that may still be
awaiting review. Caveat reader.</p>
</blockquote>
<p>Way back in Part 3, while introducing Scripts, we said that you were
likely to actually create transactions using scripts with an API, and
marked it as a topic for the future. Well, the future has now
arrived.</p>
<h2 id="create-the-script">Create the Script</h2>
<p>Creating the script is the <em>easiest</em> thing to do in Libwally.
Take the following example, a simple <a
href="/13_1_Writing_Puzzle_Scripts.md">Puzzle Script</a> that we’ve
returned to from time to time:</p>
<pre><code>OP_ADD 99 OP_EQUAL</code></pre>
<p>Using <code>btcc</code>, we can serialize that.</p>
<pre><code>$ btcc OP_ADD 99 OP_EQUAL
warning: ambiguous input 99 is interpreted as a numeric value; use 0x99 to force into hexadecimal interpretation
93016387</code></pre>
<p>Previously we built the standard P2SH script by hand, but Libwally
can actually do that for you.</p>
<p>First, Libwally has to convert the hex into bytes, since bytes are
most of what it works with:</p>
<pre><code>  int script_length = strlen(script)/2;
  unsigned char bscript[script_length];
    
  lw_response = wally_hex_to_bytes(script,bscript,script_length,&amp;written);</code></pre>
<p>Then, you run <code>wally_scriptpubkey_p2sh_from_bytes</code> with
your bytes, telling Libwally to also <code>HASH160</code> it for
you:</p>
<pre><code>  unsigned char p2sh[WALLY_SCRIPTPUBKEY_P2SH_LEN];
              
  lw_response = wally_scriptpubkey_p2sh_from_bytes(bscript,sizeof(bscript),WALLY_SCRIPT_HASH160,p2sh,WALLY_SCRIPTPUBKEY_P2SH_LEN,&amp;written);</code></pre>
<p>If you looked at the results of <code>p2sh</code>, you’d see it
was:</p>
<pre><code>a9143f58b4f7b14847a9083694b9b3b52a4cea2569ed87</code></pre>
<p>Which <a href="10_2_Building_the_Structure_of_P2SH.md">you may
recall</a> breaks apart to:</p>
<pre><code>a9 / 14 / 3f58b4f7b14847a9083694b9b3b52a4cea2569ed / 87</code></pre>
<p>That’s our old friend
<code>OP_HASH160 3f58b4f7b14847a9083694b9b3b52a4cea2569ed OP_EQUAL</code>.</p>
<p>Basically, Libwally took your serialized redeem script, hashed it for
you with SHA-256 and RIPEMD-160, and the applied the standard framing to
turn it into a proper P2SH; You did similar work in <a
href="10_2_Building_the_Structure_of_P2SH.md">§10.2</a>, but with an
excess of shell commands.</p>
<p>In fact, you can double-check your work using the same commands from
§10.2:</p>
<pre><code>$ redeemScript=&quot;93016387&quot;
$ echo -n $redeemScript | xxd -r -p | openssl dgst -sha256 -binary | openssl dgst -rmd160
(stdin)= 3f58b4f7b14847a9083694b9b3b52a4cea2569ed</code></pre>
<h2 id="create-a-transaction">Create a Transaction</h2>
<p>In order to make use of that <code>pubScriptKey</code> that you just
created, you need to create a transaction and embed the
<code>pubScriptKey</code> within (and this is the big change from
<code>bitcoin-cli</code>: you can actually hand create a transaction
with a P2SH script).</p>
<p>The process of creating a transaction in Libwally is very intensive,
just like the process for creating a PSBT, and so we’re just going to
outline it, taking one major shortcut, and then leave a method without
shortcuts for future investigation.</p>
<p>Creating a transaction itself is easy enough: you just need to tell
<code>wally_tx_init_alloc</code> your version number, your locktime, and
your number of inputs and outputs:</p>
<pre><code>  struct wally_tx *tx;
  lw_response = wally_tx_init_alloc(2,0,1,1,&amp;tx);</code></pre>
<p>Filling in those inputs and outputs is where things get tricky!</p>
<h3 id="create-a-transaction-output">Create a Transaction Output</h3>
<p>To create an output, you tell <code>wally_tx_output_init_alloc</code>
how many satoshis you’re spending and you hand it the locking
script:</p>
<pre><code>  struct wally_tx_output *tx_output;
  lw_response = wally_tx_output_init_alloc(95000,p2sh,sizeof(p2sh),&amp;tx_output);</code></pre>
<p>That part actually wasn’t hard at all, and it allowed you to at
long-last embed a P2SH in a <code>vout</code>.</p>
<p>One more command adds it to your transaction:</p>
<pre><code>  lw_response = wally_tx_add_output(tx,tx_output);</code></pre>
<h3 id="create-a-transaction-input">Create a Transaction Input</h3>
<p>Creating the input is much harder because you have to pile
information into the creation routines, not all of which is intuitively
accessible when you’re using Libwally. So, rather than going that deep
into the weeds, here’s where we take our shortcut. We write our code so
that it’s passed the hex code for a transaction that’s already been
created, and then we just reuse the input.</p>
<p>The conversion from the hex code is done with
<code>wally_tx_from_hex</code>:</p>
<pre><code>  struct wally_tx *utxo;
  lw_response = wally_tx_from_hex(utxo_hex,0,&amp;utxo);</code></pre>
<p>Then you can plunder the inputs from your hexcode to create an input
with Libwally:</p>
<pre><code>  struct wally_tx_input *tx_input;
  lw_response = wally_tx_input_init_alloc(utxo-&gt;inputs[0].txhash,sizeof(utxo-&gt;inputs[0].txhash),utxo-&gt;inputs[0].index,0,utxo-&gt;inputs[0].script,utxo-&gt;inputs[0].script_len,utxo-&gt;inputs[0].witness,&amp;tx_input);
  assert(lw_response == WALLY_OK);                      </code></pre>
<p>As you might expect, you then add that input to your transaction:</p>
<pre><code>  lw_response = wally_tx_add_input(tx,tx_input);</code></pre>
<blockquote>
<p><strong>NOTE</strong> Obviously, you’ll want to be able to create
your own inputs if you’re using Libwally for real applications, but this
is intended as a first step. And, it can actually be useful for
integrating with <code>bitcoin-cli</code>, as we’ll see in <a
href="17_7_Integrating_Libwally_and_Bitcoin-CLI.md">§16.7</a>.</p>
</blockquote>
<h3 id="print-a-transaction">Print a Transaction</h3>
<p>You theoretically could sign and send this transaction from your C
program built on Libwally, but in keeping with the idea that we’re just
using a simple C program to substitute in a P2SH, we’re going to print
out the new hex. This is done with the help of
<code>wally_tx_to_hex</code>:</p>
<pre><code>  char *tx_hex;
  lw_response = wally_tx_to_hex(tx,0, &amp;tx_hex);

  printf(&quot;%s\n&quot;,tx_hex);</code></pre>
<p>We’ll show how to make use of that in §16.7.</p>
<h2 id="test-your-replacement-script">Test Your Replacement Script</h2>
<p>You can grab the test code from the <a
href="src/17_5_replacewithscript.c">src directory</a> and compile
it:</p>
<pre><code>$  cc replacewithscript.c -lwallycore -o replacewithscript</code></pre>
<p>Afterward, prepare a hex transaction and a serialized hex script:</p>
<pre><code>hex=020000000001019527cebb072524a7961b1ba1e58fc18dd7c6fc58cd6c1c45d7e1d8fc690b006e0000000017160014cc6e8522f0287b87b7d0a83629049c2f2b0e972dfeffffff026f8460000000000017a914ba421212a629a840492acb2324b497ab95da7d1e87306f0100000000001976a914a2a68c5f9b8e25fdd1213c38d952ab2be2e271be88ac02463043021f757054fa61cfb75b64b17230b041b6d73f25ff9c018457cf95c9490d173fb4022075970f786f24502290e8a5ed0f0a85a9a6776d3730287935fb23aa817791c01701210293fef93f52e6ce8be581db62229baf116714fcb24419042ffccc762acc958294e6921b00

script=93016387</code></pre>
<p>You can then run the replacement program:</p>
<pre><code>$ ./replacewithscript $hex $script
02000000019527cebb072524a7961b1ba1e58fc18dd7c6fc58cd6c1c45d7e1d8fc690b006e0000000017160014cc6e8522f0287b87b7d0a83629049c2f2b0e972d0000000001187301000000000017a9143f58b4f7b14847a9083694b9b3b52a4cea2569ed8700000000</code></pre>
<p>You can then see the results with <code>bitcoin-cli</code>:</p>
<pre><code>$ bitcoin-cli decoderawtransaction $newhex
{
  &quot;txid&quot;: &quot;f4e7dbab45e759a7ac6e2fb0f10720cd29d047efad89fe1b569f5f4ba61fd8e6&quot;,
  &quot;hash&quot;: &quot;f4e7dbab45e759a7ac6e2fb0f10720cd29d047efad89fe1b569f5f4ba61fd8e6&quot;,
  &quot;version&quot;: 2,
  &quot;size&quot;: 106,
  &quot;vsize&quot;: 106,
  &quot;weight&quot;: 424,
  &quot;locktime&quot;: 0,
  &quot;vin&quot;: [
    {
      &quot;txid&quot;: &quot;6e000b69fcd8e1d7451c6ccd58fcc6d78dc18fe5a11b1b96a7242507bbce2795&quot;,
      &quot;vout&quot;: 0,
      &quot;scriptSig&quot;: {
        &quot;asm&quot;: &quot;0014cc6e8522f0287b87b7d0a83629049c2f2b0e972d&quot;,
        &quot;hex&quot;: &quot;160014cc6e8522f0287b87b7d0a83629049c2f2b0e972d&quot;
      },
      &quot;sequence&quot;: 0
    }
  ],
  &quot;vout&quot;: [
    {
      &quot;value&quot;: 0.00095000,
      &quot;n&quot;: 0,
      &quot;scriptPubKey&quot;: {
        &quot;asm&quot;: &quot;OP_HASH160 3f58b4f7b14847a9083694b9b3b52a4cea2569ed OP_EQUAL&quot;,
        &quot;hex&quot;: &quot;a9143f58b4f7b14847a9083694b9b3b52a4cea2569ed87&quot;,
        &quot;reqSigs&quot;: 1,
        &quot;type&quot;: &quot;scripthash&quot;,
        &quot;addresses&quot;: [
          &quot;2My2ApqGcoNXYceZC4d7fipBu4GodkbefHD&quot;
        ]
      }
    }
  ]
}</code></pre>
<p>The <code>vin</code> should just match the input you substituted in,
but it’s the <code>vout</code> that’s exciting: you’ve created a
transaction with a <code>scripthash</code>!</p>
<h2 id="summary-using-scripts-in-libwally">Summary: Using Scripts in
Libwally</h2>
<p>Creating transactions in Libwally is another topic that could take up
a whole chapter, but the great thing is that once you make this leap,
you can introduce a P2SH <code>scriptPubKey</code>, and that part alone
is pretty easy. Though the methodology detailed in this chapter requires
you to have a transaction hex already in hand (probably created with
<code>bitcoin-cli</code>) if you dig further into Libwally, you can do
it all yourself.</p>
<blockquote>
<p>:fire: <strong><em>What is the Power of Scripts in
Libwally?</em></strong> Quite simply, you can do something you couldn’t
before: create a transaction locked with an arbitrary P2SH.</p>
</blockquote>
<h2 id="whats-next">What’s Next?</h2>
<p>Learn more about “Programming Bitcoin with Libwally” in <a
href="17_6_Using_Other_Functions_in_Libwally.md">§17.6: Using Other
Functions in Libwally</a>.</p>
</body>
</html>
