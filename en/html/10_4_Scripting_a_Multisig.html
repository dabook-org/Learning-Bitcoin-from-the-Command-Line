<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>10_4_Scripting_a_Multisig</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="scripting-a-multisig">10.4: Scripting a Multisig</h1>
<p>Before we close out this intro to P2SH scripting, it’s worth
examining a more realistic example. Ever since <a
href="06_1_Sending_a_Transaction_to_a_Multisig.md">§6.1</a>, we’ve been
casually saying that the <code>bitcoin-cli</code> interface wraps its
multisig transaction in a P2SH transaction. In fact, this is the
standard methodology for creating multisigs on the Blockchain. Here’s
how that works, in depth.</p>
<h2 id="understand-the-multisig-code">Understand the Multisig Code</h2>
<p>Multisig transactions are created in Bitcoin using the
<code>OP_CHECKMULTISIG</code> code. <code>OP_CHECKMULTISIG</code>
expects a long string of arguments that looks like this:
<code>0 ... sigs ... &lt;m&gt; ... addresses ... &lt;n&gt; OP_CHECKMULTISIG</code>.
When <code>OP_CHECKMULTISIG</code> is run, it does the following:</p>
<ol type="1">
<li>Pop the first value from the stack (<code>&lt;n&gt;</code>).</li>
<li>Pop “n” values from the stack as Bitcoin addresses (hashed public
keys).</li>
<li>Pop the next value from the stack (<code>&lt;m&gt;</code>).</li>
<li>Pop “m” values from the stack as potential signatures.</li>
<li>Pop a <code>0</code> from the stack due to a mistake in the original
coding.</li>
<li>Compare the signatures to the Bitcoin adddresses.</li>
<li>Push a <code>True</code> or <code>False</code> depending on the
result.</li>
</ol>
<p>The operands of <code>OP_MULTISIG</code> are typically divided, with
the <code>0</code> and the signatures coming from the unlocking script
and the “m”, “n”, and addresses being detailed by the locking
script.</p>
<p>The requirement for that <code>0</code> as the first operand for
<code>OP_CHECKMULTISIG</code> is a consensus rule. Because the original
version of <code>OP_CHECKMULTISIG</code> accidentally popped an extra
item off the stack, Bitcoin must forever follow that standard, lest
complex redemption scripts from that time period accidentally be broken,
rendering old funds unredeemable.</p>
<blockquote>
<p>:book: <strong><em>What is a consensus rule?</em></strong> These are
the rules that the Bitcoin nodes follow to work together. In large part
they’re defined by the Bitcoin Core code. These rules include lots of
obvious mandates, such as the limit to how many Bitcoins are created for
each block and the rules for how transactions may be respent. However,
they also include fixes for bugs that have appeared over the years,
because once a bug has been introduced into the Bitcoin codebase, it
must be continually supported, lest old Bitcoins become unspendable.</p>
</blockquote>
<h2 id="create-a-raw-multisig">Create a Raw Multisig</h2>
<p>As discussed in <a
href="10_1_Understanding_the_Foundation_of_P2SH.md">§10.1: Understanding
the Foundation of P2SH</a>, multisigs are one of the standard Bitcoin
transaction types. A transaction can be created with a locking script
that uses the raw <code>OP_CHECKMULTISIG</code> command, and it will be
accepted into a block. This is the classic methodology for using
multisigs in Bitcoin.</p>
<p>As an example, we will revisit the multisig created in <a
href="06_1_Sending_a_Transaction_to_a_Multisig.md">§6.1</a> one final
time and build a new locking script for it using this methodology. As
you may recall, that was a 2-of-2 multisig built from
<code>$address1</code> and <code>$address2</code>.</p>
<p>As <code>OP_CHECKMULTISIG</code> locking script requires the “m”
(<code>2</code>), the addresses, and the “n” (<code>2</code>), you could
write the following <code>scriptPubKey</code>:</p>
<pre><code>2 $address1 $address2 2 OP_CHECKMULTISIG</code></pre>
<p>If this looks familiar, that’s because it’s the multisig that you
deserialized in <a href="10_2_Building_the_Structure_of_P2SH.md">§10.2:
Building the Structure of P2SH</a>.</p>
<pre><code>2 02da2f10746e9778dd57bd0276a4f84101c4e0a711f9cfd9f09cde55acbdd2d191 02bfde48be4aa8f4bf76c570e98a8d287f9be5638412ab38dede8e78df82f33fa3 2 OP_CHECKMULTISIG</code></pre>
<blockquote>
<p><strong>WARNING:</strong> For classic <code>OP_CHECKMULTISIG</code>
signatures, “n” must be ≤ 3 for the transaction to be standard.</p>
</blockquote>
<h2 id="unlock-a-raw-multisig">Unlock a Raw Multisig</h2>
<p>The <code>scriptSig</code> for a standard multisig address must then
submit the missing operands for <code>OP_CHECKMULTISIG</code>: a
<code>0</code> followed by “m” signatures. For example:</p>
<pre><code>0 $signature1 $signature2</code></pre>
<h3 id="run-a-raw-multisig-script">Run a Raw Multisig Script</h3>
<p>In order to spend a multisig UTXO, you run the <code>scriptSig</code>
and <code>scriptPubKey</code> as follows:</p>
<pre><code>Script: 0 $signature1 $signature2 2 $address1 $address2 2 OP_CHECKMULTISIG
Stack: [ ]</code></pre>
<p>First, you place all the constants on the stack:</p>
<pre><code>Script: OP_CHECKMULTISIG
Stack: [ 0 $signature1 $signature2 2 $address1 $address2 2 ]</code></pre>
<p>Then, the <code>OP_CHECKMULTISIG</code> begins to run. First, the “2”
is popped:</p>
<pre><code>Running: OP_CHECKMULTISIG
Stack: [ 0 $signature1 $signature2 2 $address1 $address2 ]</code></pre>
<p>Then, the “2” tells <code>OP_CHECKMULTISIG</code>to pop two
addresses:</p>
<pre><code>Running: OP_CHECKMULTISIG
Stack: [ 0 $signature1 $signature2 2 ]</code></pre>
<p>Then, the next “2” is popped:</p>
<pre><code>Running: OP_CHECKMULTISIG
Stack: [ 0 $signature1 $signature2 ]</code></pre>
<p>Then, the “2” tells <code>OP_CHECKMULTISIG</code> to pop two
signatures:</p>
<pre><code>Running: OP_CHECKMULTISIG
Stack: [ 0 ]</code></pre>
<p>Then, one more item is mistakenly popped:</p>
<pre><code>Running: OP_CHECKMULTISIG
Stack: [ ]</code></pre>
<p>Then, <code>OP_CHECKMULTISIG</code> completes its operation by
comparing the “m” signatures to the “n” addresses:</p>
<pre><code>Script:
Stack: [ True ]</code></pre>
<h2 id="understand-the-limitations-of-raw-multisig-scripts">Understand
the Limitations of Raw Multisig Scripts</h2>
<p>Unfortunately, the technique of embedding a raw multisig into a
transaction has some notable drawbacks:</p>
<ol type="1">
<li>Because there’s no standard address format for multisigs, each
sender has to: enter a long and cumbersome multisig script; have
software that allows this; and be trusted not to mess it up.</li>
<li>Because multisigs can be much longer than typical locking scripts,
the blockchain incurs more costs. This requires higher transaction fees
from the sender and creates more nuisance for every node.</li>
</ol>
<p>These were generally problems with any sort of complex Bitcoin
script, but they quickly became very real problems when applied to
multisigs, which were some of the first complex scripts to be widely
used on the Bitcoin network. P2SH transactions were created to solve
these problems, starting in 2012.</p>
<blockquote>
<p>:book: <strong><em>What is a P2SH multisig?</em></strong> P2SH
multisigs were the first implementation of P2SH transactions. They
simply package up a standard multisig transaction into a standard P2SH
transaction. This allows for address standardization; reduces data
storage; and increases “m” and “n” counts.</p>
</blockquote>
<h2 id="create-a-p2sh-multisig">Create a P2SH Multisig</h2>
<p>P2SH multisigs are the modern methodology for creating multisigs on
the Blockchains. They can be created very simply, using the same process
seen in the previous sections.</p>
<h3 id="create-the-lock-for-the-p2sh-multisig">Create the Lock for the
P2SH Multisig</h3>
<p>To create a P2SH multisig, follow the standard steps for creating a
P2SH locking script:</p>
<ol type="1">
<li>Serialize <code>2 $address1 $address2 2 OP_CHECKMULTISIG</code>.
<ol type="1">
<li><code>&lt;serializedMultiSig&gt;</code> =
“522102da2f10746e9778dd57bd0276a4f84101c4e0a711f9cfd9f09cde55acbdd2d1912102bfde48be4aa8f4bf76c570e98a8d287f9be5638412ab38dede8e78df82f33fa352ae”</li>
</ol></li>
<li>Save <code>&lt;serializedMultiSig&gt;</code> for future reference as
the redeemScript.
<ol type="1">
<li><code>&lt;redeemScript&gt;</code> =
“522102da2f10746e9778dd57bd0276a4f84101c4e0a711f9cfd9f09cde55acbdd2d1912102bfde48be4aa8f4bf76c570e98a8d287f9be5638412ab38dede8e78df82f33fa352ae”</li>
</ol></li>
<li>SHA-256 and RIPEMD-160 hash the serialized script.
<ol type="1">
<li><code>&lt;hashedMultiSig&gt;</code> =
“a5d106eb8ee51b23cf60d8bd98bc285695f233f3”</li>
</ol></li>
<li>Produce a P2SH Multisig locking script that includes the hashed
script (<code>OP_HASH160 &lt;hashedMultisig&gt; OP_EQUAL</code>).
<ol type="1">
<li><code>scriptPubKey</code> =
“a914a5d106eb8ee51b23cf60d8bd98bc285695f233f387”</li>
</ol></li>
</ol>
<p>You can then create a transaction using that
<code>scriptPubKey</code>.</p>
<h2 id="unlock-the-p2sh-multisig">Unlock the P2SH Multisig</h2>
<p>To unlock this multisig transaction requires that the recipient
produce a scriptSig that includes the two signatures and the
<code>redeemScript</code>.</p>
<h3 id="run-the-first-round-of-p2sh-validation">Run the First Round of
P2SH Validation</h3>
<p>To unlock the P2SH multisig, first confirm the script:</p>
<ol type="1">
<li>Produce an unlocking script of
<code>0 $signature1 $signature2 &lt;serializedMultiSig&gt;</code>.</li>
<li>Concatenate that with the locking script of
<code>OP_HASH160 &lt;hashedMultisig&gt; OP_EQUAL</code>.</li>
<li>Validate
<code>0 $signature1 $signature2 &lt;serializedMultiSig&gt; OP_HASH160 &lt;hashedMultisig&gt; OP_EQUAL</code>.</li>
<li>Succeed if the <code>&lt;serializedMultisig&gt;</code> matches the
<code>&lt;hashedMultisig&gt;</code>.</li>
</ol>
<h3 id="run-the-second-round-of-p2sh-validation">Run the Second Round of
P2SH Validation</h3>
<p>Then, run the multisig script:</p>
<ol type="1">
<li>Deserialize <code>&lt;serializedMultiSig&gt;</code> to
<code>2 $address1 $address2 2 OP_CHECKMULTISIG</code>.</li>
<li>Concatenate that with the earlier operands in the unlocking script,
<code>0 $signature1 $signature2</code>.</li>
<li>Validate
<code>0 $signature1 $signature2 2 $address1 $address2 2 OP_CHECKMULTISIG</code>.</li>
<li>Succeed if the operands fulfill the deserialized
<code>redeemScript</code>.</li>
</ol>
<p>Now you know how the multisig transaction in <a
href="06_1_Sending_a_Transaction_to_a_Multisig.md">§6.1</a> was actually
created, how it was validated for spending, and why that
<code>redeemScript</code> was so important.</p>
<h2 id="summary-creating-multisig-scripts">Summary: Creating Multisig
Scripts</h2>
<p>Multisigs are a standard transaction type, but they’re a bit
cumbersome to use, so they’re regularly incorporated in P2SH
transactions, as was the case in <a
href="06_1_Sending_a_Transaction_to_a_Multisig.md">§6.1</a> when we
created our first multisigs. The result is cleaner, smaller, and more
standardized — but more importantly, it’s a great real-world example of
how P2SH scripts really work.</p>
<h2 id="whats-next">What’s Next?</h2>
<p>Continue “Embedding Bitcoin Scripts” with <a
href="10_5_Scripting_a_Segwit_Script.md">§10.5: Scripting a Segwit
Script</a></p>
</body>
</html>
