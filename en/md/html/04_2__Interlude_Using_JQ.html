<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>04_2__Interlude_Using_JQ</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="interlude-using-jq">Interlude: Using JQ</h1>
<p>Creating a raw transaction revealed how more complex bitcoin-cli
results can’t easily be saved into command-line variables. The answer is
JQ, which allows you to filter out individual elements from more complex
JSON data.</p>
<h2 id="install-jq">Install JQ</h2>
<p>JQ is available from a <a
href="https://stedolan.github.io/jq/">Github repository</a>. Just
download for Linux, OS X, or Windows, as appropriate.</p>
<p>Once you’ve downloaded the binary, you can install it on your system.
If you’re working on a Debian VPS as we suggest, your installation will
look like this:</p>
<pre><code>$ mv jq-linux64 jq
$ sudo /usr/bin/install -m 0755 -o root -g root -t /usr/local/bin jq</code></pre>
<blockquote>
<p>:book: <strong><em>What is JQ?</em></strong> The repository explains
it best, saying “jq is like sed for JSON data - you can use it to slice
and filter and map and transform structured data with the same ease that
sed, awk, grep and friends let you play with text.”</p>
</blockquote>
<h2 id="use-jq-to-access-a-json-object-value-by-key">Use JQ to Access a
JSON Object Value by Key</h2>
<p><strong>Usage Example:</strong> <em>Capture the hex from a signed raw
transaction.</em></p>
<p>In the previous section, the use of <code>signrawtransaction</code>
offered an example of not being able to easily capture data into
variables due to the use of JSON output:</p>
<pre><code>$ bitcoin-cli signrawtransactionwithwallet $rawtxhex
{
  &quot;hex&quot;: &quot;02000000013a6e4279b799791049e1826602e84d2e36797e2005887b98c3ecf16b01b7f361010000006a4730440220335d15a2a2ca3ce6a302ce041686739d4a38eb0599a5ea08305de71965268d05022015f77a33cf7d613015b2aba5beb03088033625505ad5d4d0624defdbea22262b01210278608b54b8fb0d8379d3823d31f03a7c6ab0adffb07dd3811819fdfc34f8c132ffffffff01409c0000000000001976a914e7c1345fc8f87c68170b3aa798a956c2fe6a9eff88ac00000000&quot;,
  &quot;complete&quot;: true
}</code></pre>
<p>Fortunately, JQ can easily capture data of that sort!</p>
<p>To use JQ, run <code>jq</code> at the backend of a pipe, and always
use the standard invocation of <code>jq -r '.'</code>. The
<code>-r</code> tells JQ to produce raw output, which will work for
command-line variables, while the <code>.</code> tells jq to output. We
protect that argument in <code>' '</code> because we’ll need that
protection later as our <code>jq</code> invocations get more
complex.</p>
<p>To capture a specific value from a JSON object, you just list the key
after the <code>.</code>:</p>
<pre><code>$ bitcoin-cli signrawtransactionwithwallet $rawtxhex | jq -r &#39;.hex&#39;
02000000013a6e4279b799791049e1826602e84d2e36797e2005887b98c3ecf16b01b7f361010000006a4730440220335d15a2a2ca3ce6a302ce041686739d4a38eb0599a5ea08305de71965268d05022015f77a33cf7d613015b2aba5beb03088033625505ad5d4d0624defdbea22262b01210278608b54b8fb0d8379d3823d31f03a7c6ab0adffb07dd3811819fdfc34f8c132ffffffff01409c0000000000001976a914e7c1345fc8f87c68170b3aa798a956c2fe6a9eff88ac00000000</code></pre>
<p>With that tool in hand, you can capture information from JSON objects
to command-line variables:</p>
<pre><code>$ signedtx=$(bitcoin-cli signrawtransactionwithwallet $rawtxhex | jq -r &#39;.hex&#39;)
$ echo $signedtx
02000000013a6e4279b799791049e1826602e84d2e36797e2005887b98c3ecf16b01b7f361010000006a4730440220335d15a2a2ca3ce6a302ce041686739d4a38eb0599a5ea08305de71965268d05022015f77a33cf7d613015b2aba5beb03088033625505ad5d4d0624defdbea22262b01210278608b54b8fb0d8379d3823d31f03a7c6ab0adffb07dd3811819fdfc34f8c132ffffffff01409c0000000000001976a914e7c1345fc8f87c68170b3aa798a956c2fe6a9eff88ac00000000</code></pre>
<p>You can then use those variables easily and without error:</p>
<pre><code>$ bitcoin-cli sendrawtransaction $signedtx
3f9ccb6e16663e66dc119de1866610cc4f7a83079bfec2abf0598ed3adf10a78</code></pre>
<h2
id="use-jq-to-access-single-json-object-values-in-an-array-by-key">Use
JQ to Access Single JSON Object Values in an Array by Key</h2>
<p><strong>Usage Example:</strong> <em>Capture the txid and vout for a
selected UTXO.</em></p>
<p>Grabbing data out of a JSON object is easy, but what if that JSON
object is in a JSON array? The <code>listunspent</code> command offers a
great example, because it’ll usually contain a number of different
transactions. What if you want to capture specific information from
<em>one</em> of them?</p>
<p>When working with a JSON array, the first thing you need to do is
tell JQ which index to access. For example, you might have looked
through your transactions in <code>listunspent</code> and decided that
you wanted to work with the second of them. You use <code>'.[1]'</code>
to access that second element. The <code>[]</code> says that we’re
referencing a JSON array and the <code>1</code> says we want the 1st
index.</p>
<pre><code>$ bitcoin-cli listunspent | jq -r &#39;.[1]&#39;
{
  &quot;txid&quot;: &quot;91261eafae15ea53dedbea7c1db748c52bbc04a85859ffd0d839bda1421fda4c&quot;,
  &quot;vout&quot;: 0,
  &quot;address&quot;: &quot;mjehC2KHzXcBDcwTd4LhZ2GzyzrZ3Kd3ff&quot;,
  &quot;label&quot;: &quot;&quot;,
  &quot;scriptPubKey&quot;: &quot;76a9142d573900aa357a38afd741fbf24b075d263ea6e088ac&quot;,
  &quot;amount&quot;: 0.00022,
  &quot;confirmations&quot;: 9,
  &quot;spendable&quot;: true,
  &quot;solvable&quot;: true,
  &quot;desc&quot;: &quot;pkh([d6043800/0&#39;/0&#39;/3&#39;]0278608b54b8fb0d8379d3823d31f03a7c6ab0adffb07dd3811819fdfc34f8c132)#nhjc3f8y&quot;,
  &quot;safe&quot;: true
}</code></pre>
<p>You can then capture an individual value from that selected array by
(1) using a pipe <em>within</em> the JQ arguments; and then (2)
requesting the specific value afterward, as in the previous example. The
following would capture the <code>txid</code> from the 1st JSON object
in the JSON array produced by <code>listunspent</code>:</p>
<pre><code>$ bitcoin-cli listunspent | jq -r &#39;.[1] | .txid&#39;
91261eafae15ea53dedbea7c1db748c52bbc04a85859ffd0d839bda1421fda4c</code></pre>
<p>Carefully note how the <code>' 's</code> go around the whole JQ
expression <em>including</em> the pipe.</p>
<p>This method can be used to fill in variables for a UTXO that you want
to use:</p>
<pre><code>$ newtxid=$(bitcoin-cli listunspent | jq -r &#39;.[1] | .txid&#39;)
$ newvout=$(bitcoin-cli listunspent | jq -r &#39;.[1] | .vout&#39;)
$ echo $newtxid
91261eafae15ea53dedbea7c1db748c52bbc04a85859ffd0d839bda1421fda4c
$ echo $newvout
0</code></pre>
<p>Voila! We could now create a new raw transaction using our 1st UTXO
as an input, without having to type in any of the UTXO info by hand!</p>
<h2
id="use-jq-to-access-matching-json-object-values-in-an-array-by-key">Use
JQ to Access Matching JSON Object Values in an Array by Key</h2>
<p><strong>Usage Example:</strong> <em>List the value of all unspent
UTXOs.</em></p>
<p>Instead of accessing a single, specific value in a specific JSON
object, you could instead access all of a specific value across all the
JSON objects. This is done with <code>.[]</code>, where no index is
specified. For example, this would list all unspent funds:</p>
<pre><code>$ bitcoin-cli listunspent | jq -r &#39;.[] | .amount&#39;
0.0001
0.00022</code></pre>
<h2 id="use-jq-for-simple-calculations-by-key">Use JQ for Simple
Calculations by Key</h2>
<p><strong>Usage Example:</strong> <em>Sum the value of all unspent
UTXOs.</em></p>
<p>At this point, you can start using JQ output for simple math. For
example, adding up the values of those unspent transactions with a
simple <code>awk</code> script would give you the equivalent of
<code>getbalance</code>:</p>
<pre><code>$ bitcoin-cli listunspent | jq -r &#39;.[] | .amount&#39; | awk &#39;{s+=$1} END {print s}&#39;
0.00032
$ bitcoin-cli getbalance
0.00032000</code></pre>
<h2
id="use-jq-to-display-multiple-json-object-values-in-an-array-by-multiple-keys">Use
JQ to Display Multiple JSON Object Values in an Array by Multiple
Keys</h2>
<p><strong>Usage Example:</strong> <em>List usage information for all
UTXOs.</em></p>
<p>JQ can easily capture individual elements from JSON objects and
arrays and place those elements into variables. That will be its prime
use in future sections. However, it can also be used to cut down huge
amounts of information output by <code>bitcoin-cli</code> into
reasonable amounts of information.</p>
<p>For example, you might want to see a listing of all your UTXOs
(<code>.[]</code>) and get a listing of all of their most important
information (<code>.txid, .vout, .amount</code>):</p>
<pre><code>$ bitcoin-cli listunspent | jq -r &#39;.[] | .txid, .vout, .amount&#39;
ca4898d8f950df03d6bfaa00578bd0305d041d24788b630d0c4a32debcac9f36
0
0.0001
91261eafae15ea53dedbea7c1db748c52bbc04a85859ffd0d839bda1421fda4c
0
0.00022</code></pre>
<p>This makes it easy to decide which UTXOs to spend in a raw
transaction, but it’s not very pretty.</p>
<p>Fortunately, JQ also lets you be fancy. You can use <code>{}</code>s
to create new JSON objects (either for additional parsing or for pretty
output). You also get to define the name of the new key for each of your
values. The resulting output should be much more intuitive and less
prone to error (though obviously, less useful for dumping info straight
into variables).</p>
<p>The following example shows the exact same parsing of
<code>listunspent</code>, but with the each old JSON object rebuilt as a
new, abridged JSON object, with all of the new values named with their
old keys:</p>
<pre><code>$ bitcoin-cli listunspent | jq -r &#39;.[] | { txid: .txid, vout: .vout, amount: .amount }&#39;
{
  &quot;txid&quot;: &quot;ca4898d8f950df03d6bfaa00578bd0305d041d24788b630d0c4a32debcac9f36&quot;,
  &quot;vout&quot;: 0,
  &quot;amount&quot;: 0.0001
}
{
  &quot;txid&quot;: &quot;91261eafae15ea53dedbea7c1db748c52bbc04a85859ffd0d839bda1421fda4c&quot;,
  &quot;vout&quot;: 0,
  &quot;amount&quot;: 0.00022
}</code></pre>
<p>You could of course rename your new keys as you see fit. There’s
nothing magic in the original names:</p>
<pre><code>$ bitcoin-cli listunspent | jq -r &#39;.[] | { tx: .txid, output: .vout, bitcoins: .amount }&#39;
{
  &quot;tx&quot;: &quot;ca4898d8f950df03d6bfaa00578bd0305d041d24788b630d0c4a32debcac9f36&quot;,
  &quot;output&quot;: 0,
  &quot;bitcoins&quot;: 0.0001
}
{
  &quot;tx&quot;: &quot;91261eafae15ea53dedbea7c1db748c52bbc04a85859ffd0d839bda1421fda4c&quot;,
  &quot;output&quot;: 0,
  &quot;bitcoins&quot;: 0.00022
}</code></pre>
<h2 id="use-jq-to-access-json-objects-by-looked-up-value">Use JQ to
Access JSON Objects by Looked-Up Value</h2>
<p><strong>Usage Example:</strong> <em>Automatically look up UTXOs being
used in a transaction.</em></p>
<p>The JQ lookups so far have been fairly simple: you use a key to look
up one or more values in a JSON object or array. But what if you instead
want to look up a value in a JSON object … by another value? This sort
of indirect lookup has real applicability when you’re working with
transactions built on existing UTXOs. For example, it can allow you to
calculate the sum value of the UTXOs being used in a transaction,
something that is vitally important.</p>
<p>This example uses the following raw transaction. Note that this is a
more complex raw transaction with two inputs and two outputs. We’ll
learn about making those in a few sections; for now, it’s necessary to
be able to offer robust examples. Note that unlike our previous
examples, this one has two objects in its <code>vin</code> array and two
in its <code>vout</code> array.</p>
<pre><code>$ bitcoin-cli decoderawtransaction $rawtxhex
{
  &quot;txid&quot;: &quot;6f83a0b78c598de01915554688592da1d7a3047eacacc8a9be39f5396bf0a07e&quot;,
  &quot;hash&quot;: &quot;6f83a0b78c598de01915554688592da1d7a3047eacacc8a9be39f5396bf0a07e&quot;,
  &quot;size&quot;: 160,
  &quot;vsize&quot;: 160,
  &quot;version&quot;: 2,
  &quot;locktime&quot;: 0,
  &quot;vin&quot;: [
    {
      &quot;txid&quot;: &quot;d261b9494eb29084f668e1abd75d331fc2d6525dd206b2f5236753b5448ca12c&quot;,
      &quot;vout&quot;: 1,
      &quot;scriptSig&quot;: {
        &quot;asm&quot;: &quot;&quot;,
        &quot;hex&quot;: &quot;&quot;
      },
      &quot;sequence&quot;: 4294967295
    },
    {
      &quot;txid&quot;: &quot;c7c7f6371ec19330527325908a544bbf8401191645598301d24b54d37e209e7b&quot;,
      &quot;vout&quot;: 1,
      &quot;scriptSig&quot;: {
        &quot;asm&quot;: &quot;&quot;,
        &quot;hex&quot;: &quot;&quot;
      },
      &quot;sequence&quot;: 4294967295
    }
  ],
  &quot;vout&quot;: [
    {
      &quot;value&quot;: 1.00000000,
      &quot;n&quot;: 0,
      &quot;scriptPubKey&quot;: {
        &quot;asm&quot;: &quot;OP_DUP OP_HASH160 cfc39be7ea3337c450a0c77a839ad0e160739058 OP_EQUALVERIFY OP_CHECKSIG&quot;,
        &quot;hex&quot;: &quot;76a914cfc39be7ea3337c450a0c77a839ad0e16073905888ac&quot;,
        &quot;reqSigs&quot;: 1,
        &quot;type&quot;: &quot;pubkeyhash&quot;,
        &quot;addresses&quot;: [
          &quot;mzTWVv2QSgBNqXx7RC56zEhaQPve8C8VS9&quot;
        ]
      }
    },
    {
      &quot;value&quot;: 0.04500000,
      &quot;n&quot;: 1,
      &quot;scriptPubKey&quot;: {
        &quot;asm&quot;: &quot;OP_DUP OP_HASH160 166692bda9f25ced145267bb44286e8ee3963d26 OP_EQUALVERIFY OP_CHECKSIG&quot;,
        &quot;hex&quot;: &quot;76a914166692bda9f25ced145267bb44286e8ee3963d2688ac&quot;,
        &quot;reqSigs&quot;: 1,
        &quot;type&quot;: &quot;pubkeyhash&quot;,
        &quot;addresses&quot;: [
          &quot;mhZQ3Bih6wi7jP1tpFZrCcyr4NsfCapiZP&quot;
        ]
      }
    }
  ]
}</code></pre>
<h3 id="retrieve-the-values">Retrieve the Value(s)</h3>
<p>Assume that we know exactly how this transaction is constructed: we
know that it uses two UTXOs as input. To retrieve the txid for the two
UTXOs, we could use <code>jq</code> to look up the transaction’s .vin
value, then reference the .vin’s 0th array, then that array’s .txid
value. Afterward, we could do the same with the 1st array, then the same
with the .vin’s two .vout values. Easy:</p>
<pre><code>$ usedtxid1=$(bitcoin-cli decoderawtransaction $rawtxhex | jq -r &#39;.vin | .[0] | .txid&#39;)
$ echo $usedtxid1
d261b9494eb29084f668e1abd75d331fc2d6525dd206b2f5236753b5448ca12c
$ usedtxid2=$(bitcoin-cli decoderawtransaction $rawtxhex | jq -r &#39;.vin | .[1] | .txid&#39;)
$ echo $usedtxid2
c7c7f6371ec19330527325908a544bbf8401191645598301d24b54d37e209e7b

$ usedvout1=$(bitcoin-cli decoderawtransaction $rawtxhex | jq -r &#39;.vin | .[0] | .vout&#39;)
$ echo $usedvout1
1
$ usedvout2=$(bitcoin-cli decoderawtransaction $rawtxhex | jq -r &#39;.vin | .[1] | .vout&#39;)
$ echo $usedvout2
1</code></pre>
<p>However, it would be better to have a general case that
<em>automatically</em> saved all the txids of our UTXOs.</p>
<p>We already know that we can access all of the <code>.txid</code>s by
using an <code>.[]</code> array value. We can use that to build a
general .txid lookup:</p>
<pre><code>$ usedtxid=($(bitcoin-cli decoderawtransaction $rawtxhex | jq -r &#39;.vin | .[] | .txid&#39;))
$ echo ${usedtxid[0]}
d261b9494eb29084f668e1abd75d331fc2d6525dd206b2f5236753b5448ca12c
$ echo ${usedtxid[1]}
c7c7f6371ec19330527325908a544bbf8401191645598301d24b54d37e209e7b

$ usedvout=($(bitcoin-cli decoderawtransaction $rawtxhex | jq -r &#39;.vin | .[] | .vout&#39;))
$ echo ${usedvout[0]}
1
$ echo ${usedvout[1]}
1</code></pre>
<p>The only real trick here is how we saved the information using the
bash shell. Rather than saving to a variable with
<code>$(command)</code>, we instead saved to an array with
<code>($(command))</code>. We were then able to access the individual
bash array elements with a <code>${variable[n]}</code> construction. We
could instead access the whole array with <code>${variable[@]}</code>.
(Yeah, no one ever said bash was pretty.)</p>
<blockquote>
<p>:warning: <strong>WARNING:</strong> Always remember that a UTXO is a
transaction <em>plus</em> a vout. We missed the vout the first time we
wrote this JQ example, and it stopped working when we ended up with a
situation where we’d been sent two <code>vouts</code> from the same
transaction.</p>
</blockquote>
<h3 id="retrieve-the-related-objects">Retrieve the Related
Object(s)</h3>
<p>You can now use your saved <code>txid</code> and <code>vout</code>
information to reference UTXOs in <code>listunspent</code>. To find the
information on the UTXOs being used by the raw transaction, you need to
look through the entire JSON array (<code>[]</code>) of unspent
transactions. You can then choose (<code>select</code>) individual JSON
objects that include (<code>contains</code>) the txids. You
<em>then</em> select (<code>select</code>) the transactions among those
that <em>also</em> contains (<code>contain</code>) the correct vout.</p>
<p>The use of another level of pipe is the standard methodology of JQ:
you grab a set of data, then you whittle it down to all the relevant
transactions, then you whittle it down to the vouts that were actually
used from those transactions. However, the <code>select</code> and
<code>contains</code> arguments are something new. They show off some of
the complexity of JSON that goes beyond the scope of this tutorial; for
now just know that this particular invocation will work to grab matching
objects.</p>
<p>To start simply, this picks out the two UTXOs one at a time:</p>
<pre><code>$ bitcoin-cli listunspent | jq -r &#39;.[] | select (.txid | contains(&quot;&#39;${usedtxid[0]}&#39;&quot;)) | select(.vout | contains(&#39;${usedvout[0]}&#39;))&#39;
{
  &quot;txid&quot;: &quot;d261b9494eb29084f668e1abd75d331fc2d6525dd206b2f5236753b5448ca12c&quot;,
  &quot;vout&quot;: 1,
  &quot;address&quot;: &quot;miSrC3FvkPPZgqqvCiQycq7io7wTSVsAFH&quot;,
  &quot;scriptPubKey&quot;: &quot;76a91420219e4f3c6bc0f6524d538009e980091b3613e888ac&quot;,
  &quot;amount&quot;: 0.9,
  &quot;confirmations&quot;: 6,
  &quot;spendable&quot;: true,
  &quot;solvable&quot;: true
}
$ bitcoin-cli listunspent | jq -r &#39;.[] | select (.txid | contains(&quot;&#39;${usedtxid[1]}&#39;&quot;)) | select(.vout | contains(&#39;${usedvout[1]}&#39;))&#39;
{
  &quot;txid&quot;: &quot;c7c7f6371ec19330527325908a544bbf8401191645598301d24b54d37e209e7b&quot;,
  &quot;vout&quot;: 1,
  &quot;address&quot;: &quot;mzizSuAy8aL1ytFijds7pm4MuDPx5aYH5Q&quot;,
  &quot;scriptPubKey&quot;: &quot;76a914d2b12da30320e81f2dfa416c5d9499d08f778f9888ac&quot;,
  &quot;amount&quot;: 0.4,
  &quot;confirmations&quot;: 5,
  &quot;spendable&quot;: true,
  &quot;solvable&quot;: true
}</code></pre>
<p>A simple bash for-loop could instead give you <em>all</em> of your
UTXOs:</p>
<pre><code>$ for ((i=0; i&lt;${#usedtxid[*]}; i++)); do txid=${usedtxid[i]}; vout=${usedvout[i]}; bitcoin-cli listunspent | jq -r &#39;.[] | select (.txid | contains(&quot;&#39;${txid}&#39;&quot;)) | select(.vout | contains(&#39;$vout&#39;))&#39;; done;
{
  &quot;txid&quot;: &quot;d261b9494eb29084f668e1abd75d331fc2d6525dd206b2f5236753b5448ca12c&quot;,
  &quot;vout&quot;: 1,
  &quot;address&quot;: &quot;miSrC3FvkPPZgqqvCiQycq7io7wTSVsAFH&quot;,
  &quot;scriptPubKey&quot;: &quot;76a91420219e4f3c6bc0f6524d538009e980091b3613e888ac&quot;,
  &quot;amount&quot;: 0.9,
  &quot;confirmations&quot;: 7,
  &quot;spendable&quot;: true,
  &quot;solvable&quot;: true
}
{
  &quot;txid&quot;: &quot;c7c7f6371ec19330527325908a544bbf8401191645598301d24b54d37e209e7b&quot;,
  &quot;vout&quot;: 1,
  &quot;address&quot;: &quot;mzizSuAy8aL1ytFijds7pm4MuDPx5aYH5Q&quot;,
  &quot;scriptPubKey&quot;: &quot;76a914d2b12da30320e81f2dfa416c5d9499d08f778f9888ac&quot;,
  &quot;amount&quot;: 0.4,
  &quot;confirmations&quot;: 6,
  &quot;spendable&quot;: true,
  &quot;solvable&quot;: true
}
</code></pre>
<p>Note that we used yet another bit of array ugliness
<code>${#usedtxid[*]}</code> to determine the size of the array, then
accessed each value in the <code>usedtxid</code> array and each value in
the parallel <code>usedvout</code> array, putting them into simpler
variables for less-ugly access.</p>
<h2 id="use-json-for-simple-calculation-by-value">Use JSON for Simple
Calculation by Value</h2>
<p><strong>Usage Example:</strong> <em>Automatically calculate the value
of the UTXOs used in a transaction.</em></p>
<p>You can now go one step further, and request the .amount (or any
other JSON key-value) from the UTXOs you’re retrieving.</p>
<p>This example repeats the usage the <code>$usedtxid</code> and
<code>$usedvout</code> arrays that were set as follows:</p>
<pre><code>$ usedtxid=($(bitcoin-cli decoderawtransaction $rawtxhex | jq -r &#39;.vin | .[] | .txid&#39;))
$ usedvout=($(bitcoin-cli decoderawtransaction $rawtxhex | jq -r &#39;.vin | .[] | .vout&#39;))</code></pre>
<p>The same <code>for</code> script can be used to step through those
arrays, but with an added pipe in the JQ that outputs the
<code>amount</code> value for each of the UTXOs selected.</p>
<pre><code>$ for ((i=0; i&lt;${#usedtxid[*]}; i++)); do txid=${usedtxid[i]}; vout=${usedvout[i]}; bitcoin-cli listunspent | jq -r &#39;.[] | select (.txid | contains(&quot;&#39;${txid}&#39;&quot;)) | select(.vout | contains(&#39;$vout&#39;)) | .amount&#39;; done;
0.9
0.4</code></pre>
<p>At this point, you can also sum up the .amounts with an
<code>awk</code> script, to really see how much money is in the UTXOs
that the transaction is spending:</p>
<pre><code>$ for ((i=0; i&lt;${#usedtxid[*]}; i++)); do txid=${usedtxid[i]}; vout=${usedvout[i]}; bitcoin-cli listunspent | jq -r &#39;.[] | select (.txid | contains(&quot;&#39;${txid}&#39;&quot;)) | select(.vout | contains(&#39;$vout&#39;)) | .amount&#39;; done | awk &#39;{s+=$1} END {print s}&#39;
1.3</code></pre>
<p>Whew!</p>
<h2 id="use-jq-for-complex-calculations">Use JQ for Complex
Calculations</h2>
<p><strong>Usage Example:</strong> <em>Calculate the fee for a
transaction.</em></p>
<p>Figuring out the complete transaction fee at this point just requires
one more bit of math: determining how much money is going through the
.vout. That’s a simple use of JQ where you just use <code>awk</code> to
sum up the <code>value</code> of all the <code>vout</code>
information:</p>
<pre><code>$ bitcoin-cli decoderawtransaction $rawtxhex | jq -r &#39;.vout  [] | .value&#39; | awk &#39;{s+=$1} END {print s}&#39;
1.045</code></pre>
<p>To complete the transaction fee calculation, you subtract the .vout
.amount (1.045) from the .vin .amount (1.3).</p>
<p>To do this, you’ll need to install <code>bc</code>:</p>
<pre><code>$ sudo apt-get install bc</code></pre>
<p>Putting it all together creates a complete calculator in just five
lines of script:</p>
<pre><code>$ usedtxid=($(bitcoin-cli decoderawtransaction $rawtxhex | jq -r &#39;.vin | .[] | .txid&#39;))
$ usedvout=($(bitcoin-cli decoderawtransaction $rawtxhex | jq -r &#39;.vin | .[] | .vout&#39;))
$ btcin=$(for ((i=0; i&lt;${#usedtxid[*]}; i++)); do txid=${usedtxid[i]}; vout=${usedvout[i]}; bitcoin-cli listunspent | jq -r &#39;.[] | select (.txid | contains(&quot;&#39;${txid}&#39;&quot;)) | select(.vout | contains(&#39;$vout&#39;)) | .amount&#39;; done | awk &#39;{s+=$1} END {print s}&#39;)
$ btcout=$(bitcoin-cli decoderawtransaction $rawtxhex | jq -r &#39;.vout  [] | .value&#39; | awk &#39;{s+=$1} END {print s}&#39;)
$ echo &quot;$btcin-$btcout&quot;| /usr/bin/bc
.255</code></pre>
<p>And that’s also a good example of why you double-check your fees:
we’d intended to send a transaction fee of 5,000 satoshis, but sent
255,000 satoshis instead. Whoops!</p>
<blockquote>
<p>:warning: <strong>WARNING:</strong> The first time we wrote up this
lesson, we genuinely miscalculated our fee and didn’t see it until we
ran our fee calculator. It’s <em>that</em> easy, then your money is
gone. (The example above is actually from our second iteration of the
calculator, and that time we made the mistake on purpose.)</p>
</blockquote>
<p>For more JSON magic (and if any of this isn’t clear), please read the
<a href="https://stedolan.github.io/jq/manual/">JSON Manual</a> and the
<a href="https://github.com/stedolan/jq/wiki/Cookbook">JSON
Cookbook</a>. We’ll be regularly using JQ in future examples.</p>
<h2 id="make-some-new-aliases">Make Some New Aliases</h2>
<p>JQ code can be a little unwieldy, so you should consider adding some
longer and more interesting invocations to your ~/.bash_profile.</p>
<p>Any time you’re looking through a large mass of information in a JSON
object output by a <code>bitcoin-cli</code> command, consider writing an
alias to strip it down to just what you want to see.</p>
<pre><code>alias btcunspent=&quot;bitcoin-cli listunspent | jq -r &#39;.[] | { txid: .txid, vout: .vout, amount: .amount }&#39;&quot;</code></pre>
<h2 id="run-the-transaction-fee-script">Run The Transaction Fee
Script</h2>
<p>The <a href="src/04_2_i_txfee-calc.sh">Fee Calculation Script</a> is
available in src-code directory. You can download it and save it as
<code>txfee-calc.sh</code>.</p>
<blockquote>
<p>:warning: <strong>WARNING:</strong> This script has not been robustly
checked. If you are going to use it to verify real transaction fees you
should only do it as a triple-check after you’ve already done all the
math yourself.</p>
</blockquote>
<p>Be sure the permissions on the script are right:</p>
<pre><code>$ chmod 755 txfee-calc.sh</code></pre>
<p>You can then run the script as follows:</p>
<pre><code>$ ./txfee-calc.sh $rawtxhex
.255</code></pre>
<p>You may also want to create an alias:</p>
<pre><code>alias btctxfee=&quot;~/txfee-calc.sh&quot;</code></pre>
<h2 id="summary-using-jq">Summary: Using JQ</h2>
<p>JQ makes it easy to extract information from JSON arrays and objects.
It can also be used in shell scripts for fairly complex calculations
that will make your life easier.</p>
<h2 id="whats-next">What’s Next?</h2>
<p>Continue “Sending Bitcoin Transactions” with <a
href="04_3_Creating_a_Raw_Transaction_with_Named_Arguments.md">§4.3
Creating a Raw Transaction with Named Arguments</a>.</p>
</body>
</html>
