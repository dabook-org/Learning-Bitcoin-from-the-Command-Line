<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>18_5_Accessing_Bitcoind_with_Rust</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="accessing-bitcoind-with-rust">18.5: Accessing Bitcoind with
Rust</h1>
<blockquote>
<p>:information_source: <strong>NOTE:</strong> This section has been
recently added to the course and is an early draft that may still be
awaiting review. Caveat reader.</p>
</blockquote>
<p>This section explains how to interact with <code>bitcoind</code>
using the Rust programming language and the <a
href="https://github.com/rust-bitcoin/rust-bitcoincore-rpc"><code>bitcoincore-rpc</code>
crate</a>.</p>
<h2 id="set-up-rust">Set Up Rust</h2>
<p>You need to install both Rust and Cargo.</p>
<p>They can be installed via <code>curl</code>. Just use the “default”
installation:</p>
<pre class="vim"><code>$ curl https://sh.rustup.rs -sSf | sh</code></pre>
<p>If everything goes well, you should see:</p>
<pre class="vim"><code>Rust is installed now. Great!</code></pre>
<p>You’ll then need to either logout and back in, or else add Cargo’s
binary directory to your path by hand:</p>
<pre><code>$ source $HOME/.cargo/env</code></pre>
<h3 id="set-up-bitcoincore-rpc">Set Up <code>bitcoincore-rpc</code></h3>
<p>For most programming languages, you need to install a Bitcoin RPC
library before you create your first project, but here you’ll do it as
part of your project creation.</p>
<h3 id="create-a-bitcoincore-rpc-project">Create a
<code>bitcoincore-rpc</code> Project</h3>
<p>You can create a new project using
<code>cargo new btc_test</code>:</p>
<pre><code>$ cargo new btc_test
     Created binary (application) `btc_test` package</code></pre>
<p>This will create a <code>btc_test</code> directory that contains a
“hello world” source-code example in <code>src/main.rs</code> and a
<code>Cargo.toml</code> file.</p>
<p>You’ll compile and run your code with <code>cargo run</code>:</p>
<pre><code>$ cd btc_test
$ cargo run
   Compiling btc_test v0.1.0 (/home/standup/btc_test)
    Finished dev [unoptimized + debuginfo] target(s) in 0.14s
     Running `target/debug/btc_test`
Hello, world!</code></pre>
<blockquote>
<p>:information_source: <strong>NOTE:</strong> if you run into error
<code>linker ‘cc’ not found</code>, you’ll have to install a C compiler.
If on Linux, go ahead and install the <a
href="https://www.ostechnix.com/install-development-tools-linux/">development
tools</a>.</p>
</blockquote>
<p>In order to access the <code>bitcoincore-rpc</code> crate (library),
you must add it to your <code>Cargo.toml</code> file under the section
<code>dependencies</code>:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>[dependencies]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>bitcoincore<span class="op">-</span>rpc <span class="op">=</span> <span class="st">&quot;0.11.0&quot;</span></span></code></pre></div>
<p>When you <code>cargo run</code> again, it will install the crate and
its (numerous) dependencies.</p>
<pre><code>$ cargo run
    Updating crates.io index
   ...
   Compiling bitcoin v0.23.0
   Compiling bitcoincore-rpc-json v0.11.0
   Compiling bitcoincore-rpc v0.11.0
   Compiling btc_test v0.1.0 (/home/standup/btc_test)
    Finished dev [unoptimized + debuginfo] target(s) in 23.56s
     Running `target/debug/btc_test`
Hello, world!</code></pre>
<p>When you are using <code>bitcoin-rpc</code>, you will typically need
to include the following:</p>
<pre><code>use bitcoincore_rpc::{Auth, Client, RpcApi};</code></pre>
<h2 id="build-your-connection">Build Your Connection</h2>
<p>To create a Bitcoin <code>RPC client</code>, modify the
<code>src/main.rs</code>:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">bitcoincore_rpc::</span><span class="op">{</span>Auth<span class="op">,</span> Client<span class="op">,</span> RpcApi<span class="op">};</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> rpc <span class="op">=</span> <span class="pp">Client::</span>new(</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;http://localhost:18332&quot;</span><span class="op">.</span>to_string()<span class="op">,</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Auth::</span>UserPass(<span class="st">&quot;StandUp&quot;</span><span class="op">.</span>to_string()<span class="op">,</span> <span class="st">&quot;password&quot;</span><span class="op">.</span>to_string())<span class="op">,</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>As usual, make sure to insert your proper user name and password from
<code>~/.bitcoin/bitcoin.conf</code>. Here, they’re used as the
arguments for <code>Auth::UserPass</code>.</p>
<blockquote>
<p>:link: <strong>TESTNET vs MAINNET:</strong> And, as usual, use port
8332 for mainnet.</p>
</blockquote>
<p>When you’re done, you should also close your connection:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> _ <span class="op">=</span> rpc<span class="op">.</span>stop()<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p><code>cargo run</code> should successfully compile and run the
example with one warning <code>warning: unused variable: rpc</code></p>
<h3 id="make-an-rpc-call">Make an RPC Call</h3>
<p>RPC calls are made using the <code>rpc</code> <code>Client</code>
that you created:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> mining_info <span class="op">=</span> rpc<span class="op">.</span>get_mining_info()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{:#?}&quot;</span><span class="op">,</span> mining_info)<span class="op">;</span></span></code></pre></div>
<p>Generally, the words in the RPC call are separated by
<code>_</code>s. A complete list is available at the <a
href="https://crates.io/crates/bitcoincore-rpc">crate docs</a>.</p>
<h3 id="make-an-rpc-call-with-arguments">Make an RPC Call with
Arguments</h3>
<p>Sending an RPC call with arguments using Rust just requires knowing
how the function is laid out. For example, the <code>get_block</code>
function is defined as follows in the <a
href="https://docs.rs/bitcoincore-rpc/0.11.0/bitcoincore_rpc/trait.RpcApi.html#method.get_block">docs</a>:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> get_block(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> hash<span class="op">:</span> <span class="op">&amp;</span>BlockHash) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>Block<span class="op">&gt;</span></span></code></pre></div>
<p>You just need to allow it to borrow a blockhash, which can be
retrieved (for example) by <code>get_best_block_hash</code>.</p>
<p>Here’s the complete code to retrieve a block hash, turn that into a
block, and print it.</p>
<pre><code>    let hash = rpc.get_best_block_hash().unwrap();
    let block = rpc.get_block(&amp;hash).unwrap();
    
    println!(&quot;{:?}&quot;, block);</code></pre>
<blockquote>
<p><strong>NOTE:</strong> Another possible call that we considered for
this section was <code>get_address_info</code>, but unfortunately as of
this writing, the <code>bitcoincore-rpc</code> function doesn’t work
with recent versions of Bitcoin Core due to the crate not addressing the
latest API changes in Bitcoin Core. We expect this will be solved in the
next crate’s release, but in the meantime, <em>caveat
programmer</em>.</p>
</blockquote>
<h3 id="run-your-code">Run Your Code</h3>
<p>You can access the <a href="src/18_5_main-getinfo.rs">src code</a>
and run it. Unfortunately, the “Block” info will come out a bit ugly
because this example doesn’t include a library to prettify it.</p>
<pre><code>$ cargo run 
   Compiling btc_test v0.1.0 (/home/standup/btc_test)
    Finished dev [unoptimized + debuginfo] target(s) in 1.61s
     Running `target/debug/btc_test`
GetMiningInfoResult {
    blocks: 1832335,
    current_block_weight: None,
    current_block_tx: None,
    difficulty: 4194304.0,
    network_hash_ps: 77436285865245.1,
    pooled_tx: 4,
    chain: &quot;test&quot;,
    warnings: &quot;Warning: unknown new rules activated (versionbit 28)&quot;,
}
Block { header: BlockHeader { version: 541065216, prev_blockhash: 000000000000027715981d5a3047daf6819ea3b8390b73832587594a2074cbf5, merkle_root: 4b2e2c2754b6ed9cf5c857a66ed4c8642b6f6b33b42a4859423e4c3dca462d0c, time: 1599602277, bits: 436469756, nonce: 218614401 }, txdata: [Transaction { version: 1, lock_time: 0, input: [TxIn { previous_output: OutPoint { txid: 0000000000000000000000000000000000000000000000000000000000000000, vout: 4294967295 }, script_sig: Script(OP_PUSHBYTES_3 8ff51b OP_PUSHBYTES_22 315448617368263538434f494e1d00010320a48db852 OP_PUSHBYTES_32 &lt;push past end&gt;), sequence: 4294967295, witness: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] }], output: [TxOut { value: 19721777, script_pubkey: Script(OP_HASH160 OP_PUSHBYTES_20 011beb6fb8499e075a57027fb0a58384f2d3f784 OP_EQUAL) }, TxOut { value: 0, script_pubkey: Script(OP_RETURN OP_PUSHBYTES_36 aa21a9ed63363f3620ab5e38b8860a50c84050e5ec31af3636bbd73f01ba9f14103100ee) }] }, Transaction { version: 2, lock_time: 1832282, input: [TxIn { previous_output: OutPoint { txid: cbf880f73d421baf0aa4f0d28e63ba00e5bc6bd934b91eb0641354ce5ca42f7e, vout: 0 }, script_sig: Script(OP_PUSHBYTES_22 00146b8dbd32e5deb90d22934e1513bae6e70156cd50), sequence: 4294967294, witness: [[48, 68, 2, 32, 13, 89, 205, 30, 67, 24, 196, 83, 65, 224, 44, 138, 98, 58, 81, 135, 132, 209, 23, 166, 23, 44, 3, 228, 95, 102, 166, 214, 62, 38, 155, 147, 2, 32, 119, 2, 34, 246, 148, 255, 166, 10, 90, 52, 242, 32, 74, 241, 123, 148, 89, 199, 197, 3, 152, 134, 242, 215, 109, 61, 241, 241, 13, 70, 86, 207, 1], [2, 192, 145, 170, 206, 55, 4, 36, 138, 145, 217, 50, 19, 73, 130, 136, 245, 131, 184, 142, 239, 75, 13, 67, 17, 177, 57, 86, 151, 139, 89, 35, 109]] }], output: [TxOut { value: 1667908, script_pubkey: Script(OP_HASH160 OP_PUSHBYTES_20 908ca2b8b49ccf53efa2226afa85f6cc58dfd7e7 OP_EQUAL) }, TxOut { value: 9093, script_pubkey: Script(OP_DUP OP_HASH160 OP_PUSHBYTES_20 42ee67664ce16edefc68ad0e4c5b7ce2fc2ccc18 OP_EQUALVERIFY OP_CHECKSIG) }] },  ...] }</code></pre>
<h2 id="look-up-funds">Look Up Funds</h2>
<p>You can look up funds without optional arguments using the
<code>get_balance</code> function:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> balance <span class="op">=</span> rpc<span class="op">.</span>get_balance(<span class="cn">None</span><span class="op">,</span> <span class="cn">None</span>)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;Balance: {:?} BTC&quot;</span><span class="op">,</span> balance<span class="op">.</span>as_btc())<span class="op">;</span></span></code></pre></div>
<p>As shown, the <code>as_btc()</code> function helps to output the
balance in a readable form:</p>
<pre><code>Balance: 3433.71692741 BTC</code></pre>
<h2 id="create-an-address">Create an Address</h2>
<p>Creating an address demonstrates how to make an RPC call with
multiple optional arguments specified (e.g., a label and an address
type).</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Generate a new address</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> myaddress <span class="op">=</span> rpc</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>get_new_address(<span class="dt">Option</span><span class="pp">::</span><span class="cn">Some</span>(<span class="st">&quot;BlockchainCommons&quot;</span>)<span class="op">,</span> <span class="dt">Option</span><span class="pp">::</span><span class="cn">Some</span>(<span class="pp">json::AddressType::</span>Bech32))</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;address: {:?}&quot;</span><span class="op">,</span> myaddress)<span class="op">;</span></span></code></pre></div>
<p>This will also require you to bring the <code>json</code> definition
into scope:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">bitcoincore_rpc::</span><span class="op">{</span>json<span class="op">,</span> Auth<span class="op">,</span> Client<span class="op">,</span> RpcApi<span class="op">};</span></span></code></pre></div>
<h2 id="send-a-transaction">Send a Transaction</h2>
<p>You now have everything you need to create a transaction, which will
be done in five parts:</p>
<ol type="1">
<li>List UTXOs</li>
<li>Populate Variables</li>
<li>Create Raw Transaction</li>
<li>Sign Transaction</li>
<li>Send Transaction</li>
</ol>
<h3 id="list-utxos">1. List UTXOs</h3>
<p>To start the creation of a transaction, you first find a UTXO to use.
The following takes the first UTXO with at least 0.01 BTC</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> unspent <span class="op">=</span> rpc</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="op">.</span>list_unspent(</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="cn">None</span><span class="op">,</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="cn">None</span><span class="op">,</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="cn">None</span><span class="op">,</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="cn">None</span><span class="op">,</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Option</span><span class="pp">::</span><span class="cn">Some</span>(<span class="pp">json::</span>ListUnspentQueryOptions <span class="op">{</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>        minimum_amount<span class="op">:</span> <span class="dt">Option</span><span class="pp">::</span><span class="cn">Some</span>(<span class="pp">Amount::</span>from_btc(<span class="dv">0.01</span>)<span class="op">.</span>unwrap())<span class="op">,</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>        maximum_amount<span class="op">:</span> <span class="cn">None</span><span class="op">,</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>        maximum_count<span class="op">:</span> <span class="cn">None</span><span class="op">,</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>        minimum_sum_amount<span class="op">:</span> <span class="cn">None</span><span class="op">,</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">,</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> selected_tx <span class="op">=</span> <span class="op">&amp;</span>unspent[<span class="dv">0</span>]<span class="op">;</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;selected unspent transaction: {:#?}&quot;</span><span class="op">,</span> selected_tx)<span class="op">;</span></span></code></pre></div>
<p>This will require bringing more structures into scope:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">bitcoincore_rpc::bitcoin::</span><span class="op">{</span>Address<span class="op">,</span> Amount<span class="op">};</span></span></code></pre></div>
<p>Note that you’re passing <code>list_unspent</code> five variables.
The first four (<code>minconf</code>, <code>maxconf</code>,
<code>addresses</code>, and <code>include_unsafe</code>) aren’t used
here. The fifth is <code>query_options</code>, which we haven’t used
before, but has some powerful filtering options, including the ability
to only look at UTXOs with a certain minimum (or maximum) value.</p>
<h3 id="populate-variables">2. Populate Variables</h3>
<p>To begin populating the variables that you’ll need to create a new
transaction, you create the input from the <code>txid</code> and the
<code>vout</code> of the UTXO that you selected:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> selected_utxos <span class="op">=</span> <span class="pp">json::</span>CreateRawTransactionInput <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    txid<span class="op">:</span> selected_tx<span class="op">.</span>txid<span class="op">,</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    vout<span class="op">:</span> selected_tx<span class="op">.</span>vout<span class="op">,</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    sequence<span class="op">:</span> <span class="cn">None</span><span class="op">,</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Next, you can calculate the amount you’re going to spend by
subtracting a mining fee from the funds in the UTXO:</p>
<pre><code>// send all bitcoin in the UTXO except a minor value which will be paid to miners
let unspent_amount = selected_tx.amount;
let amount = unspent_amount - Amount::from_btc(0.00001).unwrap();</code></pre>
<p>Finally, you can create a hash map of the address and the amount to
form the output:</p>
<pre><code>let mut output = HashMap::new();
output.insert(
    myaddress.to_string(),
    amount,
);</code></pre>
<p>Another trait is necessary for the output variable:
<code>HashMap</code>. It allows you to store values by key, which you
need to represent <code>{address : amount}</code> information.</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::collections::</span>HashMap<span class="op">;</span></span></code></pre></div>
<h3 id="create-raw-transaction">3. Create Raw Transaction</h3>
<p>You are ready to create a raw transaction:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> unsigned_tx <span class="op">=</span> rpc</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>create_raw_transaction(<span class="op">&amp;</span>[selected_utxos]<span class="op">,</span> <span class="op">&amp;</span>output<span class="op">,</span> <span class="cn">None</span><span class="op">,</span> <span class="cn">None</span>)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<h3 id="sign-transaction">4. Sign Transaction</h3>
<p>Signing your transaction can be done with a simple use of
<code>sign_raw_transaction_with_wallet</code>:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> signed_tx <span class="op">=</span> rpc</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>sign_raw_transaction_with_wallet(<span class="op">&amp;</span>unsigned_tx<span class="op">,</span> <span class="cn">None</span><span class="op">,</span> <span class="cn">None</span>)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;signed tx {:?}&quot;</span><span class="op">,</span> signed_tx<span class="op">.</span>transaction()<span class="op">.</span>unwrap())<span class="op">;</span></span></code></pre></div>
<h3 id="send-transaction">5. Send Transaction</h3>
<p>Finally, you can broadcast the transaction:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> txid_sent <span class="op">=</span> rpc</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>send_raw_transaction(<span class="op">&amp;</span>signed_tx<span class="op">.</span>transaction()<span class="op">.</span>unwrap())</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> txid_sent)<span class="op">;</span></span></code></pre></div>
<h3 id="run-your-code-1">Run Your Code</h3>
<p>You can now run the complete code from the <a
href="src/18_5_main-sendtx.rs">src</a>.</p>
<pre><code>$ cargo run
   Compiling btc_test v0.1.0 (/home/standup/btc_test)
warning: unused variable: `unspent_amount`
  --&gt; src/main.rs:86:9
   |
86 |     let unspent_amount = selected_tx.amount;
   |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_unspent_amount`
   |
   = note: `#[warn(unused_variables)]` on by default

warning: 1 warning emitted

    Finished dev [unoptimized + debuginfo] target(s) in 2.11s
     Running `target/debug/btc_test`
Balance: 0.01031434 BTC
address: tb1qx5jz36xgt9q2rkh4daee8ewfj0g5z05v8qsua2
selected unspent transaction: ListUnspentResultEntry {
    txid: 84207ffec658ae29ad1fdd330d8a13613303c3cf281ce628fadeb7636ffb535e,
    vout: 1,
    address: Some(
        tb1qrcf8c29966tvqxhwrtd2se3rj6jeqtll3r46a4,
    ),
    label: None,
    redeem_script: None,
    witness_script: None,
    script_pub_key: Script(OP_0 OP_PUSHBYTES_20 1e127c28a5d696c01aee1adaa8662396a5902fff),
    amount: Amount(1029734 satoshi),
    confirmations: 1246,
    spendable: true,
    solvable: true,
    descriptor: Some(
        &quot;wpkh([ce0c7e14/0\&#39;/1\&#39;/26\&#39;]02c581259ba7e6aef6d7ea23adb08f7c7f10c4c678f2e097a4074639e7685d4805)#j3pctfhf&quot;,
    ),
    safe: true,
}
unsigned tx Transaction {
    version: 2,
    lock_time: 0,
    input: [
        TxIn {
            previous_output: OutPoint {
                txid: 84207ffec658ae29ad1fdd330d8a13613303c3cf281ce628fadeb7636ffb535e,
                vout: 1,
            },
            script_sig: Script(),
            sequence: 4294967295,
            witness: [],
        },
    ],
    output: [
        TxOut {
            value: 1028734,
            script_pubkey: Script(OP_0 OP_PUSHBYTES_20 352428e8c85940a1daf56f7393e5c993d1413e8c),
        },
    ],
}
signed tx Transaction { version: 2, lock_time: 0, input: [TxIn { previous_output: OutPoint { txid: 84207ffec658ae29ad1fdd330d8a13613303c3cf281ce628fadeb7636ffb535e, vout: 1 }, script_sig: Script(), sequence: 4294967295, witness: [[48, 68, 2, 32, 98, 230, 199, 113, 156, 242, 158, 42, 148, 229, 239, 44, 9, 226, 127, 219, 72, 51, 26, 135, 44, 212, 179, 200, 213, 63, 56, 167, 0, 55, 236, 235, 2, 32, 41, 43, 30, 109, 60, 162, 124, 67, 20, 126, 4, 107, 124, 95, 9, 200, 132, 246, 147, 235, 176, 55, 59, 45, 190, 18, 211, 201, 143, 62, 163, 36, 1], [2, 197, 129, 37, 155, 167, 230, 174, 246, 215, 234, 35, 173, 176, 143, 124, 127, 16, 196, 198, 120, 242, 224, 151, 164, 7, 70, 57, 231, 104, 93, 72, 5]] }], output: [TxOut { value: 1028734, script_pubkey: Script(OP_0 OP_PUSHBYTES_20 352428e8c85940a1daf56f7393e5c993d1413e8c) }] }
b0eda3517e6fac69e58ae315d7fe7a1981e3a858996cc1e3135618cac9b79d1a</code></pre>
<h2 id="summary-accessing-bitcoind-with-rust">Summary: Accessing
Bitcoind with Rust</h2>
<p><code>bitcoincore-rpc</code> is a simple and robust crate that will
allow you to interact with Bitcoin RPC using Rust. However, as of this
writing it has fallen behind Bitcoin Core, which might cause some issues
with usage.</p>
<h2 id="whats-next">What’s Next?</h2>
<p>Learn more about “Talking to Bitcoin in Other Languages” in <a
href="18_6_Accessing_Bitcoind_with_Swift.md">18.6: Accessing Bitcoin
with Swift</a>.</p>
</body>
</html>
