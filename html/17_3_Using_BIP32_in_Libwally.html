<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>17_3_Using_BIP32_in_Libwally</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="using-bip32-in-libwally">17.3: Using BIP32 in Libwally</h1>
<blockquote>
<p>:information_source: <strong>NOTE:</strong> This section has been
recently added to the course and is an early draft that may still be
awaiting review. Caveat reader.</p>
</blockquote>
<p>In <a href="17_2_Using_BIP39_in_Libwally.md">§17.2</a>, you were able
to use entropy to generate a seed and its related mnemonic. As you may
recall from <a href="03_5_Understanding_the_Descriptor.md">§3.5:
Understanding the Descriptor</a>, a seed is the basis of a Hierchical
Deterministic (HD) Wallet, where that single seed can be used to
generate many addresses. So how do you get from the seed to actual
addresses? That’s where <a
href="https://en.bitcoin.it/wiki/BIP_0032">BIP32</a> comes in.</p>
<h2 id="create-an-hd-root">Create an HD Root</h2>
<p>To create a HD address requires starting with a seed, and then
walking down the hierarchy until the point that you create
addresses.</p>
<p>That starts off easily enough, you just generate a seed, which you
already did in the previous section:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">unsigned</span> <span class="dt">char</span> entropy<span class="op">[</span><span class="dv">16</span><span class="op">];</span>  </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  randombytes_buf<span class="op">(</span>entropy<span class="op">,</span> <span class="dv">16</span><span class="op">);</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> <span class="op">*</span>mnem <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  lw_response <span class="op">=</span> bip39_mnemonic_from_bytes<span class="op">(</span>NULL<span class="op">,</span>entropy<span class="op">,</span><span class="dv">16</span><span class="op">,&amp;</span>mnem<span class="op">);</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">unsigned</span> <span class="dt">char</span> seed<span class="op">[</span>BIP39_SEED_LEN_512<span class="op">];</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> seed_len<span class="op">;</span>  </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  lw_response <span class="op">=</span> bip39_mnemonic_to_seed<span class="op">(</span>mnem<span class="op">,</span>NULL<span class="op">,</span>seed<span class="op">,</span>BIP39_SEED_LEN_512<span class="op">,&amp;</span>seed_len<span class="op">);</span></span></code></pre></div>
<h3 id="generate-a-root-key">Generate a Root Key</h3>
<p>With a seed in hand, you can then generate a master extended key with
the <code>bip32_key_from_seed_alloc</code> function (or alternatively
the <code>bip32_key_from_seed</code>, which doesn’t do the
<code>alloc</code>):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> ext_key <span class="op">*</span>key_root<span class="op">;</span>  </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  lw_response <span class="op">=</span> bip32_key_from_seed_alloc<span class="op">(</span>seed<span class="op">,</span><span class="kw">sizeof</span><span class="op">(</span>seed<span class="op">),</span>BIP32_VER_TEST_PRIVATE<span class="op">,</span><span class="dv">0</span><span class="op">,&amp;</span>key_root<span class="op">);</span></span></code></pre></div>
<p>As you can see, you’ll need to tell it what version of the key to
return, in this case <code>BIP32_VER_TEST_PRIVATE</code>, a private
testnet key.</p>
<blockquote>
<p>:link: <strong>TESTNET vs MAINNET:</strong> On mainnet, you’d instead
ask for <code>BIP32_VER_MAIN_PRIVATE</code>.</p>
</blockquote>
<h3 id="generate-xpub-xprv">Generate xpub &amp; xprv</h3>
<p>Whenever you have a key in hand, you can turn it into xpub or xprv
keys for distribution with the <code>bip32_key_to_base58</code> command.
You just tell it whether you want a <code>PRIVATE</code> (xprv) or
<code>PUBLIC</code> (xpub) key:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> <span class="op">*</span>xprv<span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  lw_response <span class="op">=</span> bip32_key_to_base58<span class="op">(</span>key_root<span class="op">,</span> BIP32_FLAG_KEY_PRIVATE<span class="op">,</span> <span class="op">&amp;</span>xprv<span class="op">);</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> <span class="op">*</span>xpub<span class="op">;</span>  </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  lw_response <span class="op">=</span> bip32_key_to_base58<span class="op">(</span>key_root<span class="op">,</span> BIP32_FLAG_KEY_PUBLIC<span class="op">,</span> <span class="op">&amp;</span>xpub<span class="op">);</span></span></code></pre></div>
<h2 id="understand-the-hierarchy">Understand the Hierarchy</h2>
<p>Before going further, you need to understand how the hierarchy of an
HD wallet works. As discussed in <a
href="03_5_Understanding_the_Descriptor.md">§3.5</a>, a derivation path
describes the tree that you follow to get to a hierarchical key, so
<code>[0/1/0]</code> is the 0th child of the 1st child of the 0th child
of a root key. Sometimes part of that derivation are marked with
<code>'</code>s or <code>h</code>s to show hardened derivations, which
increase security: <code>[0'/1'/0']</code>.</p>
<p>However, for HD wallets, each of those levels of the hierachy is used
in a very specific way. This was originally defined in <a
href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP44</a>
and was later updated for Segwit in [BIP84].</p>
<p>Altogether, a BIP32 derivation path is defined to have five
levels:</p>
<ol type="1">
<li><strong>Purpose.</strong> This is usually set to <code>44'</code> or
<code>84'</code>, depending on the BIP that is being followed.</li>
<li><strong>Coin.</strong> For Mainnet bitcoins, this is
<code>0'</code>, for testnet it’s <code>1'</code>.</li>
<li><strong>Account.</strong> A wallet can contain multiple, discrete
accounts, starting with <code>0'</code>.</li>
<li><strong>Change.</strong> External addresses (for distribution) are
set to <code>0</code>, while internal addresses (for change) are set to
<code>1</code>.</li>
<li><strong>Index.</strong> The nth address for the hierarchy, starting
with <code>0</code>.</li>
</ol>
<p>So on testnet, the zeroth adddress for an external address for the
zeroth account for testnet coins using the BIP84 standards is
<code>[m/84'/1'/0'/0/0]</code>. That’s the address you’ll be creating
momentarily.</p>
<blockquote>
<p>:link: <strong>TESTNET vs MAINNET:</strong> For mainnet, that’d be
<code>[m/84'/0'/0'/0/0]</code></p>
</blockquote>
<h3 id="understand-the-hierarchary-in-bitcoin-core">Understand the
Hierarchary in Bitcoin Core</h3>
<p>We’ll be using the above hierarchy for all HD keys in Libwally, but
note that this standard isn’t used by Bitcoin Core’s
<code>bitcoin-cli</code>, which instead uses <code>[m/0'/0'/0']</code>
for the 0th external address and <code>[m/0'/1'/0']</code> for the 0th
change address.</p>
<h2 id="generate-an-address">Generate an Address</h2>
<p>To generate an address, you thus have to dig down through the whole
hierarchy.</p>
<h3 id="generate-an-account-key">Generate an Account Key</h3>
<p>One way to do this is to use the
<code>bip32_key_from_parent_path_alloc</code> function to drop down
several levels of a hierarchy. You embed the levels in an array:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint32_t</span> path_account<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span>BIP32_INITIAL_HARDENED_CHILD<span class="op">+</span><span class="dv">84</span><span class="op">,</span> BIP32_INITIAL_HARDENED_CHILD<span class="op">+</span><span class="dv">1</span><span class="op">,</span> BIP32_INITIAL_HARDENED_CHILD<span class="op">};</span></span></code></pre></div>
<p>Here we’ll be looking at the zeroth hardened child (that’s the
account) or the first hardened child (that’s testnet coins) of the 84th
hardened child (that’s the BIP84 standard):
<code>[m/84'/1'/0']</code>.</p>
<p>You can then use that path to generate a new key from your old
key:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> ext_key <span class="op">*</span>key_account<span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  lw_response <span class="op">=</span> bip32_key_from_parent_path_alloc<span class="op">(</span>key_root<span class="op">,</span>path_account<span class="op">,</span><span class="kw">sizeof</span><span class="op">(</span>path_account<span class="op">),</span>BIP32_FLAG_KEY_PRIVATE<span class="op">,&amp;</span>key_account<span class="op">);</span></span></code></pre></div>
<p>Every time you have a new key, you can use that to generate new xprv
and xpub keys, if you desire:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>  lw_response <span class="op">=</span> bip32_key_to_base58<span class="op">(</span>key_account<span class="op">,</span> BIP32_FLAG_KEY_PRIVATE<span class="op">,</span> <span class="op">&amp;</span>a_xprv<span class="op">);</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  lw_response <span class="op">=</span> bip32_key_to_base58<span class="op">(</span>key_account<span class="op">,</span> BIP32_FLAG_KEY_PUBLIC<span class="op">,</span> <span class="op">&amp;</span>a_xpub<span class="op">);</span></span></code></pre></div>
<h3 id="generate-an-address-key">Generate an Address Key</h3>
<p>Alternatively, you can use the
<code>bip32_key_from_parent_alloc</code> function, which just drops down
one level of the hierarchy at a time. The following example drops down
to the 0th child of the account key (which is the external address) and
then the 0th child of that. This would be useful because then you could
continue generating the 1st address, the 2nd address, and so on from
that external key:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> ext_key <span class="op">*</span>key_external<span class="op">;</span>  </span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  lw_response <span class="op">=</span> bip32_key_from_parent_alloc<span class="op">(</span>key_account<span class="op">,</span><span class="dv">0</span><span class="op">,</span>BIP32_FLAG_KEY_PRIVATE<span class="op">,&amp;</span>key_external<span class="op">);</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> ext_key <span class="op">*</span>key_address<span class="op">;</span>  </span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  lw_response <span class="op">=</span> bip32_key_from_parent_alloc<span class="op">(</span>key_external<span class="op">,</span><span class="dv">0</span><span class="op">,</span>BIP32_FLAG_KEY_PRIVATE<span class="op">,&amp;</span>key_address<span class="op">);</span></span></code></pre></div>
<blockquote>
<p>:warning: <strong>WARNING:</strong> At some point in this hierarchy,
you might decide to generate <code>BIP32_FLAG_KEY_PUBLIC</code> instead
of <code>BIP32_FLAG_KEY_PRIVATE</code>. Obviously this decision will be
based on your security and your needs, but remember that you only need a
public key to generate the actual address.</p>
</blockquote>
<h3 id="generate-an-address-1">Generate an Address</h3>
<p>Finally, you’re ready to generate an address from your final key. All
you do is run <code>wally_bip32_to_addr_segwit</code> using your final
key and a description of what sort of address this is.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> <span class="op">*</span>segwit<span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  lw_response <span class="op">=</span> wally_bip32_key_to_addr_segwit<span class="op">(</span>key_address<span class="op">,</span><span class="st">&quot;tb&quot;</span><span class="op">,</span><span class="dv">0</span><span class="op">,&amp;</span>segwit<span class="op">);</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  printf<span class="op">(</span><span class="st">&quot;[m/84&#39;/1&#39;/0&#39;/0/0]: %s</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span>segwit<span class="op">);</span></span></code></pre></div>
<blockquote>
<p>:link: <strong>TESTNET vs MAINNET:</strong> The <code>tb</code>
argument defines a testnet address. For mainnet instead use
<code>bc</code>.</p>
</blockquote>
<p>There is also a <code>wally_bip32_key_to_address</code> function,
which can be used to generate a legacy address or a nested Segwit
address.</p>
<h2 id="test-hd-code">Test HD Code</h2>
<p>The code for these HD example can, as usual, be found in the <a
href="src/17_3_genhd.c">src directory</a>.</p>
<p>You can compile and test it:</p>
<pre><code>$ cc genhd.c -lwallycore -lsodium -o genhd
$ ./genhd
Mnemonic: behind mirror pond finish borrow wood park foam guess mail regular reflect
Root xprv key: tprv8ZgxMBicQKsPdLFXmZ6VegTxcmeieNpRUq8J2ahXxSaK2aF7CGqAc14ZADLjdHJdCr8oR2Zng9YH1x1A7EBaajQLVGNtxc4YpFejdE3wyj8
Root xpub key: tpubD6NzVbkrYhZ4WoHKfCm64685BoAeoi1L48j5K6jqNiNhs4VspfeknVgRLLiQJ3RkXiA9VxguUjmEwobtmrXNbhXsPHfm9W5HJR9DKRGaGJ2
Account xprv key: tprv8yZN7h6SPvJXrhAk56z6cwHQE6qZBRreB9fqqZJ1Xd1nLci3Rw8HTmqNkpFNgf3eZx8hYzhFWafUhHSt3HgF13aHvCE6kveS7gZAyfQwMDi
Account xpub key: tpubDWFQG78gYHzCkACXxkeh2LwWo8MVLm3YkTGd85LJwtpBB6xp4KwseGTEvxjeZNhnCNPdfZqRcgcZZAka4tD3xGS2J53WKHPMRhG357VKsqT
[m/84&#39;/1&#39;/0&#39;/0/0]: tb1q0knqq26ek59pfl7nukzqr28m2zl5wn2f0ldvwu</code></pre>
<h2 id="summary-using-bip32-in-libwally">Summary: Using BIP32 in
Libwally</h2>
<p>An HD wallet allows you to generate a vast number of keys from a
single seed. You now know how those keys are organized under BIP44,
BIP84, and Bitcoin Core and how to derive them, starting with either a
seed or mnemonic words.</p>
<blockquote>
<p>:fire: <strong><em>What is the power of BIP32?</em></strong> Keys are
the most difficult (and most dangerous) element of most cryptographic
operations. If you lose them, you lose whatever the key protected. BIP32
ensures that you just need to know one key, the seed, rather than a huge
number of different keys for different addresses.</p>
</blockquote>
<blockquote>
<p>:fire: <strong><em>What is the power of BIP32 in
Libwally?</em></strong> Bitcoind already does HD-based address creation
for you, which means you don’t usually have to worry about deriving
addresses in this way. However, using the BIP32 functions of Libwally
can be very useful if you have an offline machine where you need to
derive addresses, possibly based on a seed passed out of
<code>bitcoind</code> to your offline device (or vice-versa).</p>
</blockquote>
<h2 id="whats-next">What’s Next?</h2>
<p>Learn more about “Programming Bitcoin with Libwally” in <a
href="17_4_Using_PSBTs_in_Libwally.md">17.4: Using PSBTs in
Libwally</a>.</p>
</body>
</html>
